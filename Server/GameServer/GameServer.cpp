//----------------------------------------------------------------------------------------------------------------------------------------------
//2021/11/21/ 인프런 Lock 기초 강의
// GameServer.cpp 파일
//----------------------------------------------------------------------------------------------------------------------------------------------

//atomic보다 lock은 일반적인 상황에서 더 잘쓰인다
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
//운영체제마다 임계영역등 다 분할이 되 있었는데 
// //c++11에서 통합됨
//lock을 걸기 위해 필요한 헤더 
#include <mutex>

//벡터에서 push_back 상황시 일반적인 메모리 확장
//----------------------------------------------------==============
//[1][2][3]        // 1. push_back 상황에서 공간이 없으면
//[1][2][3][][][]  // 2. 새로 메모리를 할당 한후 위에 데이터를 복사해온 후
                   // 3. 위에 데이터를 삭제한다
//----------------------------------------------------==============
//멀티쓰레드 환경에서 벡터에 메모리 확장
//----------------------------------------------------==============
//1번 쓰레드
//[1][2][3]        // 1. push_back 상황에서 공간이 없으면
//[1][2][3][][][]  // 2. 새로 메모리를 할당 한후 위에 데이터를 복사해온 후
				   // 3. 윈래 메모리를 삭제
//------------------------------------------------------------------------				    
//2번 쓰레드			
//                 //위 작업을 동시에 실행하다 
//                 //3번에서 1번 쓰레드가 삭제한 메모리를 
//                 //다시 delete한다	 - 더블 free문제 발생     
//----------------------------------------------------==============



vector<int32> v;

// Mutual Exclusive (상호 배타적) - 나만 사용할꺼야!!
mutex m; // 일종의 자물쇠
// 락을 거는 범위에 따라 많이 달라짐


//락에서 조심해야 할것
// 1,
//락을 재귀적으로 사용할수있나? - 리퀼스 뮤텍스라고 따로 존재하는 버전이 있긴함
//mmo 처럼 코드가 복잡해지면 내부에서 락을 건후 다른 함수들을 호출하고 그 함수에서 내부에서 또 락을 걸기도 함
//따라서 재귀적인 락이 필요함

//2.
// 락을 잡고 실수로 락을 안풀어 줄때
// 규모가 큰 코드일 경우 락을 풀고 잠그고를 수동으로 하는건 나쁜 습관임
//해결 방법
// RAII (Resource Acquisition is Inintialization)
// 어떤 레퍼 클래스를 만드러 가지고 생성자에서 락을 걸고 소멸자에서 락을 푼다
// 일종의 자동문을 만들어줌
// 약간의 부하가 있지만 안전함!!
//예시
template<typename T>
class LockGuard
{
public:
	LockGuard(T& m)
	{
		_mutex = &m;
		_mutex->lock();
	}
	~LockGuard()
	{
		_mutex->unlock();
	}
private:
	T* _mutex;
};


void  Push()
{
	for (int32 i = 0; i < 10000; i++)
	{ 
		//싱글스레드로 작동하는 개념 - 느림
		//순차적 접근 가능
		//자물쇠 잠그기
		//m.lock(); 
		
		//lock과 unlock을 명시적으로 호출하는게 아니라
		//생성자와 소멸자를 통해 자동으로 호출함
		//조건식을 통해 중간에 break 걸려도 unlock이 누락될일 없어짐
		//자동문을 만들어줌
		//LockGuard<std::mutex> lockGuard(m);
		//물론 표준에도 만들어져있음!!
		//std::lock_guard<std::mutex> lockGuard(m);
		//추가적인 기능이 있는 락도 존재!!
		//std::unique_lock<std::mutex> uniqueLock(m); // 이러면 일반적인 lock_guard와 동일하고
		std::unique_lock<std::mutex> uniqueLock(m,std::defer_lock); // 당장 락을 잠그지 않고 defer_lock이란 조건을 주고
		uniqueLock.lock(); // 이걸 호출한 순간 락이 걸림 - 락을 뒤로 미뤄서 유도리있게 동작 하게됨 
		                   // 아무래도 추가 적인 변수을 집어 넣야 해서 일반 적인 lock_guard 보다 살짝 느림 
		                   // 때문에 가변운 코드면 lock_quard() 쓰는게 좋음
		
		v.push_back(i);

		if (i == 5000)
		{
			//m.unlock();
			break;
		}

		//자물쇠 풀기
		//m.unlock();
	}
}

int main()
{
	//가령 reserve를 통해 미리 데이터를 할당해서 크래쉬를 해결할려고 해도
	//몇개에 데이터가 분실되어있다
	//이유는?
	//reserve를 통해 데이터를 옮기는 일은 없고 뒤에 추가만 하면 되지만
	//벡터의 동작방식은 지금까지 데이터를 몇개를  집어넣었는지 사이즈를 관리하다가
	//사이즈를 통해 인덱스를 지정해서 집어넣는다
	//하지만 멀티쓰레드 환경에서 이런걸 고려 안하기 때문에
	//동시에 여러개의 쓰레드가 같은 인덱스에 집어 넣을려함
	//해당 인덱스에 값을 다 넣지 않았는데 다른쓰레드에서 비어 있다 판단해서 같은 위치에 쓰려함
	//이런 상황은 크래쉬는 발생안하고 데이터만 분실된 상황이라 더욱 더 버그를 찾기 어려운 위험한 상황
	
	//아토믹에 벡터를 넣게되면 벡터의 세부적인 기능을 사용할수없음
	//벡터에 아토믹 쓰면 안됨

	//때문에 한번에 한명만 접근하게  락은 걸어야함
	
	v.reserve(20000);


	std::thread t1(Push);
	std::thread t2(Push);

	t1.join();
	t2.join();

	cout << v.size() << endl;
    //지금 까지 써온 컨테이너 자료구조들은 멀티쓰레드 환경에서 동작하지않는다고 가정해야함
	//바로 크래쉬가 발생함
}

//----------------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------------

