//----------------------------------------------------------------------------------------------------------------------------------------------
//2021/11/20/ 인프런 Atomic 강의
// GameServer.cpp 파일
//----------------------------------------------------------------------------------------------------------------------------------------------

#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
//c++ 표준에 아토믹이 추가됨
//#include <atomic>을 추가하면 리눅스이건 윈도우이건 사용가능함
#include <atomic>

// atomic atom(원자)
// atomic : All - Or - Nothing
// 다 실행이 되거나 하나도 실행이 안되거나 둘중하나의 상황만 존재할수있게하는걸 아토믹 연산이라 함
// 아토믹 연산은 DB관련 수업에서도 나오게 됨
//겅합 발생시 늦은 쓰레드가 앞에 쓰레드가 완료할때까지 대기함
//순서는 cpu가 정함
// 하지만 atomic은 일반 변수보다 느리니 모든 변수를 아토믹하게 만들순없다
//꼭필요할때만 사용해야함


//DB
// 아이템 교환 상황
// A라는 유저 인벤에서 집행검을 빼고
// B라는 유저 인벤에서 집행검을 추가
// 두가지 작업이 동시에 실행되지 않는다면
// A작업후 서버의 문제가 생기면 
// B가 아이템을 못받게 됨
//여기서 아토믹 연산이 필요하게됨

//int sum = 0;

//아토믹 활용
//아토믹 클래스는 템플릿으로 만들어 졌기 때문에 어떤 데이터를 넣을건지 명시해서 사용함
atomic<int32> sum = 0;

void Add()
{
	// 숫자가 만이 넘어가면 보기 편하게 작은 따음표로 구분해주자
	for (int32 i = 0; i < 100'0000; ++i)
	{
		//윈도우에서 이걸로 아토믹을 추가 할 수도 있는데  지금은  통합이 되어서
		// c++ 표준에서 atomic을 사용할수있게됨
		//interlockedadd()

		//sum++; // 아토믹을 활용하면 밑에 코드의 문제가 해결됨 
		sum.fetch_add(1); // sum++로 쓰면 이게 그냥 int인지 아토믹 int인지 헷갈리니까 경우에 따라서 이런식으로 쓰기도 함
						  // 밑에 3단계가 아닌 다른 구조로 컴파일러가 작동함


		//sum++ 코드는 한줄이지만 의사코드에서는 3줄이됨
		//int32 eax = sum;
		//eax = 0
		//eax = eax + 1;
		//eax = 1
		//sum = eax; // 이런식으로 레지스터에 저장된 eax 변수의 값을 복사해 오기 때문에 여러 쓰레드에서 동시 접근시 값의 충돌이 발생 
		//sum =1
		// 때문에 동기화가 필요하다
	}
}

void Sub()
{
	for (int32 i = 0; i < 100'0000; ++i)
	{
		sum.fetch_add(-1); // sum++로 쓰면 이게 그냥 int인지 아토믹 int인지 헷갈리니까 경우에 따라서 이런식으로 쓰기도 함
		//sum--;
		//sum-- 코드는 한줄이지만 의사코드에서는 3줄이됨
		//int32 eax = sum;
		//eax = 0
		//eax = eax - 1;
		//eax = -1
		//sum = eax;
		//sum = -1
	}
}

int main()
{
	// 싱글 쓰레드 경우
	// 0이 나옴
	Add();
	Sub();
	cout << sum << endl;

	//멀티 쓰레드 경우
	// 0 이 아닌 이상한 값이 나옴 
	std::thread t1(Add);
	std::thread t2(Sub);

	t1.join();
	t2.join();

	cout << sum << endl;

	//멀티 쓰레드 환경에선 공유데이터 관련 문제가 발생한다
	// 스텍에 경우 각기 자신에 영역을 가지고 있어 sum을 스텍 메모리에서 선언했다면 다른 쓰레드에 영향을 받지 않음
	// 힙이나 데이터 영역 같은 경우 쓰레드끼리 서로 공유해서 가지고 있음

}

//----------------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------------

