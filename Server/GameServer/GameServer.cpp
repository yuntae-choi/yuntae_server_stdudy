//----------------------------------------------------------------------------------------------------------------------------------------------
//2021/11/20/ 인프런 쓰레드 생성 강의
// GameServer.cpp 파일
//----------------------------------------------------------------------------------------------------------------------------------------------

#include "pch.h"
#include <iostream>
#include "CorePch.h"

//2021/11/20/ 인프런 쓰레드 생성 강의
//윈도우에 종속 적인 api을 활용하게 되면 혹시라도 나중에 리눅스로 넘어가게 될때 수정 사항이 많아짐
//#include <windows.h>
//하지만 c++11 부터 쓰레드를 생성하는것이 쓰레드로 들어왔다
//때문에 #include <thread>을 쓰면 공용적인 코드로 다양한 환경에서 돌아갈수있게됨
//모던한 방법을 쓰자!! - 물론 서버는 거의 변동이 없지만 혹시라도 호환이 필요할수도 있기때문에 공용적인 코드를 쓰는게 좋다
#include <thread>

void HelloThread()
{
	cout << "hello world" << endl;
};

//인자가 추가 된 버전
void HelloThread_2(int32 num)
{
	cout << num << endl;
};


int main()
{
	// 11월 19일 시작 설정 강의
	//HelloWorld();

	//2021/11/20/ 인프런 쓰레드 생성 강의
	// 시스템 콜 (OS 커널 요청)
	// 쓰레드 생성도 운영체제한테 요청 해야함
	//cout << "hello world" << endl;

	//윈도우에 종속 적인 api을 활용하게 되면 혹시라도 나중에 리눅스로 넘어가게 될때 수정 사항이 많아짐
	//::CreateThread();

	//쓰레드 객체를 생성하자마자 엔트리 포인트라는 쓰레드의 메인함수 같은걸 생성할수있다
	//std::thread t(HelloThread);


	//이런 식으로 객체 호출 후에 쓰레드 함수를 호출 할수있음
	//std::thread t;
	//auto id1 = t.get_id(); // 쓰레드 id 0 번
	//t = std::thread(HelloThread); // 호출할 함수를 지정해줘야 쓰레드 함수가 할당됨 !!!!!

	//자주 활용하는 쓰레드 클래스 함수 5가지
	//t.hardware_concurrency(); //cpu 코어 개수? - 하지만 백프로 정확하지 않으므로 0을 리턴할때도 있음
	//t.get_id(); // 쓰레드마다 id
	//t.detach(); // std::thread 객체에서 실제 쓰레드를 분리(전통적으로 리눅스쪽에서 쓰레드를 분리하는걸 데몬프로세스라고 부르기도함 그럴떄 응용할수도있다) - 선언한 t 객체를 가지고 이제 정보를 추출 할수 없게됨- 쓰레드를 백그라운드 쓰레드로 독립적으로 작용하게 만듬
	//t.joinable(); // 실제 연결된 쓰레드인지 확인해줌
	//t.join();


	//int32 count = t.hardware_concurrency(); //cpu 코어 개수? - 하지만 백프로 정확하지 않으므로 0을 리턴할때도 있음

	//auto id2 = t.get_id(); // 제대로 할당됨 쓰레드id

	//쓰레드 객체에서 생성을 할떄 꼭 함수일 필요는 없고 어떠한 callable 타입이면 된다 - 콜러블 타입은 ()가 붙은 모든 호출 문 ex) 함수..
	// ...은 c++11에 추가된 베레딕 템플릭이란 문법 한마디로 인자개수를 자유자제로 받을수있다
	// 때문에 이런식으로 인자를 넣을 수있음
	//std::thread t(HelloThread_2, 10);


	//메인쓰레드가 먼저 끝나게 되면 오류가 생김
	//때문에 호출한 쓰레드가 끝날때 까지 메인쓰레드가 기다려줘야함
	// join(); 끝날때 까지 기다려주겠다
	//if (t.joinable())// 이런식으로 활용가능
		//t.join();

	//쓰레드 다수를 벡터로 관리 하는법
	//하지만 num 값이 순서대로 출력이 안된다 - 동기화를 안해서 순서 보장 안됨
	vector<std::thread> v;

	for (int32 i = 0; i < 10; ++i)
	{
		v.push_back(std::thread(HelloThread_2, i));
	}

	for (int32 i = 0; i < 10; ++i) {
		if (v[i].joinable())// 이런식으로 활용가능
			v[i].join();
	}

	cout << "HelloMain" << endl;
}

//----------------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------------

